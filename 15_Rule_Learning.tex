\chapter{规则学习}
% # 【《机器学习》第15章】规则学习

机器学习中的规则学习更像是用形式化的语言归纳出传统的依靠人类经验去对未知样本进行判别的过程.因此本章内容学习起来更加直观易懂.

\section{基本概念}
% ## 15.1 基本概念

\begin{itemize}
\item 规则(rule):语义明确,能描述数据分布所隐含的客观规律或领域概念.
\item 规则学习(rule learning):从训练数据集中学习出一组能用于对未见示例进行判别的规则.
\end{itemize}

规则学习具有更好的可解释性,能够更自然地在学习过程中引入领域知识.

规则集合中的每条规则都可看做一个子模型,规则集合是这些子模型的一个集成.如果一个示例被多条判别结果不同的规则覆盖时,则发生了"冲突"(conflict).解决冲突的过程称为"冲突消解"(conflict resolution),常用的方法有投票法,排序法,元规则法等.

如果有示例未能被规则所覆盖,则设置一条"默认规则"(default rule).

从形式语言表达能力而言,规则分为两类:

\begin{itemize}
\item 命题规则(Propositional rule):由源自命题(propositional atom)和逻辑连接词与,或,非和蕴含构成的简单陈述句.
\item 一阶规则(first-order rule):基本成分是能描述事物的属性或者关系的"原子公式"(atomic formula).
\end{itemize}

显然,一阶规则能够表达更复杂的关系,因此被称为"关系型规则"(relational rule).

\section{序贯覆盖}
% ## 15.2 序贯覆盖

规则学习的目标是产生一个覆盖尽可能多的样例的规则集.最直接的做法是"序贯覆盖"(sequential convering).形式化地说,给定正例集合与反例集合,学习任务是基于候选文字集合$\mathcal F=\{\mathbf f_k\}$来生成最优规则$\mathbf r$.

穷尽搜索方法在属性和候选值较多时会由于组合爆炸而不可行.现实任务中一般有两种策略来产生规则:
\begin{itemize}
\item "自顶向下"(top-down):从比较一般的规则开始,逐渐添加新文字以缩小规则覆盖范围,知道满足预定条件为止.
\item "自底向上"(bottom-up):从比较特殊的规则开始,逐渐删除文字以扩大规则覆盖范围,直到满足条件为止.
\end{itemize}

\section{剪枝优化}
% ## 15.3 剪枝优化

与决策树剪枝类似,规则生成剪枝的目的是为了缓解过拟合的风险.同时需要考虑两个问题:
\begin{itemize}
\item 规则生成本质上是一个贪心搜索过程,是否贪心搜索过程都有陷入过拟合的风险?
\item 决策树生成的过程是不是一个贪心搜索过程?
\end{itemize}

剪枝过程如果发生在规则生长过程中,则被称作"预剪枝",如果发生在规则产生后,则被称为"后剪枝".剪枝通常是基于某种性能度量指标来评估增或删除逻辑文字前后的规则性能,或增或删除规则前后的规则集性能,从而判断是否需要剪枝.

剪枝还可借助统计显著性检验\footnote{统计显著性检验概念是什么?}来进行.书中举了一个例子CN2算法(见P352).

后剪枝常用的策略是"减错剪枝"(Reduced Error Pruning, REP).基本流程是:
\begin{enumerate}
\item 将样本集分为训练集和测试集
\item 在训练集上学习得到规则集$\mathcal R$
\item 在每轮迭代中穷举$\mathcal R$中所有剪枝可能
\item 在测试集上进行验证选出性能最好的测试集$\mathcal R'$
\item 在$\mathcal R'$基础上进行下一轮剪枝,直到性能不再提升为止.
\end{enumerate}

REP性能复杂度为$O(m^4)$.IREP(Incremental REP)算法将复杂度降到$O(m\log^2m)$,其做法为:
\begin{enumerate}
\item 在生成每条规则前,将样本集分为训练集和测试集
\item 在训练集上生成一条规则$\mathbf r$
\item 立即在验证集上对$\mathbf r$进行REP剪枝,得到$\mathbf r'$
\item 将$\mathbf r'$覆盖的样例去除,在更新的样例集上重复上述过程.
\end{enumerate}
若将剪枝机制与其他一些后处理手段结合起来对规则集进行优化,则往往能获得更好的效果.以RIPPER为例(具体算法流程见P353),其泛化性能超过很多决策树算法,而且学习速度也比大多数决策树算法要快,其根源正是在此.

\section{一阶规则学习}
% ## 15.4 一阶规则学习

命题规则学习难以处理对象之间的"关系"(relation),而关系信息在很多任务中非常重要.如果将样例进行一一比较,并且将比较的结果进行记录,则生成的记录称为"关系数据"(relational data),其中由原样本属性转化而来的原子公式称为"背景知识"(background knowledge).
\begin{itemize}
\item 一阶逻辑表示的样本标记有更高的空间复杂度.
\item 如果通过比较关系会不会使得学习结果陷入局部最优?
\end{itemize}

通常在一阶规则中所有出现的变量都被全称量词限定,但是在不影响理解的情况下可以进行省略.此外,一阶规则学习的优势在于:
\begin{enumerate}
\item 具有强大的表达能力
\item 容易地引入领域知识
\end{enumerate}

通常机器学习引入领域知识的方法为:在现有的属性集上基于领域知识构造出新属性;基于领域知识设计某种函数来对假设空间加以约束.

FOIL(First-Order Inductive Learner)是著名的一阶规则,它是一种遵循序贯覆盖框架且采用自顶向下的规则归纳策略.采用文字的准则为FOIL增益(FOIL gain)
\begin{equation}
F_Gain=\hat m_+\times(\log_2\frac{\hat m_+}{\hat m_+\hat m_-}-\log_2\frac{m_+}{m_++m_+})
\end{equation}

其中$\hat m_+$和$\hat m_-$分别为增加候选文字后新规则所覆盖的正,反例数;$m_+$和$m_-$为原规则覆盖的正,反例数.

采用上述增益的原因为,关系数据中正例数往往少于反例数,因此通常对正例应该赋予更多的关注\footnote{imbalanced-data是否可以借鉴这种思想?}.

FOIL可大致看做命题规则学习与归纳逻辑程序设计之间的过渡,其自顶向下的规则生成过程不能支持函数和逻辑表达能力嵌套,但是它是把命题规则学习通过变量替换等操作直接转化为一阶规则学习,因此比一般归纳逻辑程序设计技术更高效.

\section{归纳逻辑程序设计(Inductive Logic Programming, ILP)}
% ## 15.5 归纳逻辑程序设计(Inductive Logic Programming, ILP)

IPL在一阶规则学习中引入了函数和逻辑表达式嵌套.一方面,其使得机器学习系统具备了更为强大的表达能力;另一方面,IPL可看作使用机器学习技术来解决基于背景知识的逻辑程序归纳.

\subsection{最小一般泛化}
% ### 15.5.1 最小一般泛化

归纳逻辑程序设计采用自底向上的规则生成策略,直接将一个或者多个正例所对应的具体事实作为初始规则,再对规则逐步进行泛化以增加其对样例的覆盖率.目前的基础技术是"最小一般泛化"(Least General Generalization, LGG).

给定一阶公式$\mathbf r_1$和$\mathbf r_2$,LGG先找出涉及相同谓词的文字,然后对文字中每个位置的常量逐一进行考察,若常量在两个文字中相同则保持不变,记为$LGG(t,t)=t$;否则将它们替换为同一个新变量,并将该替换应用于公式的所有其他位置.

在归纳逻辑程序设计中,获得LGG后,可将其看做单条规则加入规则集,最后再用前几节介绍的技术进一步优化(如对规则集后剪枝).

\subsection{逆归结}
% ### 15.5.2 逆归结

归结原理与逆归结分别与实际生活中的演绎和归纳相对应.基于归结原理,我们可将貌似复杂的逻辑规则与背景知识联系起来化繁为简;而基于逆归结,我们可基于背景知识来发明新的概念和关系.

基于以下四种完备的逆归结操作,可以实现逆归结.
\begin{itemize}
\item 吸收(absorption)
\item 辨识(identification)
\item 内构(intra-construction)
\item 互构(inter-construction)
\end{itemize}

归结,逆归结都能容易地扩展为一阶逻辑形式;与命题逻辑的主要不同之处在于,一阶逻辑的归结,逆归结通常需要进行合一置换操作.
\begin{itemize}
\item "置换"(substitution)是用某些项来替换逻辑表达式中的变量.
\item "合一"(unification)是用一种变量置换令两个或者多个逻辑表达式相等.
\end{itemize}

逆归结的一大特点是能自动发明新谓词,这些新谓词可能对应于样例属性和背景知识中不存在的新知识,对知识发现与精化有重要意义.
